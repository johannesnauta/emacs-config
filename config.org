#+TITLE:		config
#+SUBTITLE: Emacs configuration using org-babel
#+AUTHOR:   Johannes Nauta
#+STARTUP:  indent

* Literate Emacs configuration
Welcome to my literate Emacs configuration using =org-babel=.

** How to use this literal program
+ Pull this file from my [[https://github.com/github-jnauta/emacs-config][Github repository]]
+ =org-babel= should already be installed when using a version of Emacs >=24 
+ Replace the contents of your =~/.emacs.d/init.el= with one line
#+begin_src emacs-lisp
(org-babel-load-file "~/.emacs.d/config.org")
#+end_src
+ Enjoy Emacs

Note that some of the libraries that are used might need to be installed. If
that is the case, simply =M-x package-install= the particular package that
raises an error.
  
* =use-package=: The package manager
=use-package= is my current bread-and-butter for installing packages to use with
Emacs. It not only allows you to install packages, but allows configuring the
packages as well. This is often done lazily, so you get much more performance
out of Emacs when you let =use-package= do all the configuration when possible.
First we need to use the built-in package manager to actually download
=use-package= when it is not available.
#+begin_src emacs-lisp :tangle yes
  ;; Use the built-in package manager and specify archive
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/") t)
  ;; Initialize built-in package management
  (package-initialize)
  ;; Install use-package if not available
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+end_src

Then we can actually load =use-package=
#+begin_src emacs-lisp :tangle yes
  ;; Load use-package by requiring it, to ensure it has been loaded
  (eval-when-compile
    (require 'use-package))
#+end_src

* Changing Emacs default behavior
** Ensure environment variables inside Emacs look the same as in the shell
In some cases, e.g. when not starting Emacs from the terminal, Emacs' shell has
different environment variables than the user's shell. This is inconvenient as
it might result in some packages not finding the binaries of installed
libraries. A prime example is LaTeX, of which the =texlive= installation is
exported to the ="$PATH"= variable. Therefore, we use =exec-path-from-shell= to
ensure that Emacs's environment variables are the same as in the shell.
#+begin_src emacs-lisp :tangle yes
  (use-package exec-path-from-shell
    :ensure t)
  ;; Sets $MANPATH, $PATH and exec-path from your shell, only when using the GUI.
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize))
#+end_src
** Suppressing default behaviors
There are some default behaviors which are just annoying, such as the startup
splash screen or the sound on error or EOF. We can suppress some more things
while we're at it.
#+begin_src emacs-lisp :tangle yes
  (setq inhibit-startup-message t)  ;; Suppress startup splash screen
  (setq ring-bell-function 'ignore) ;; Suppress sound on error or EOF
  (menu-bar-mode -1)                ;; Turn off menu bar
  (tool-bar-mode -1)                ;; Turn off tool bar
  (setq scroll-conservatively 100)  ;; Make scrolling better
  (show-paren-mode 1)               ;; Highlight matching parentheses
#+end_src

** Enabling default behaviors
In contrast, some behavior is not turned on by default, so we do that here
#+begin_src emacs-lisp :tangle yes
  (global-display-line-numbers-mode 1)	;; Display line numbers in every buffer
  (defalias 'yes-or-no-p 'y-or-n-p)     ;; All confirmations to single letters
  (delete-selection-mode 1)             ;; Replace highlighted/selected text
  ;; Build a list of recently opened files
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (setq recentf-max-saved-items 25)
#+end_src

** Specifying other defaults
Finally, there are some defaults that are sensible to set, such as the TAB
width, among others. You can define other global keybindings here as well, as
long as these are not originating from a package that is handled by
=use-package=. These should be handled by =use-package= itself when loaded.
#+begin_src emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)						;; Spaces instead of tabs
  (setq-default tab-width 2)			              ;; Default tab width
  (setq-default fill-column 80)                 ;; Default column width
  (setq indent-line-function 'insert-tab)       ;; Indent current line(s) according to current major mode
  ;; Font and font size
  (set-face-attribute 'default nil :font "Roboto Mono Medium")
  (set-face-attribute 'default nil :height 115)
#+end_src

*** Global keybindings unrelated to =use-package=
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-o") #'other-window)
#+end_src

** Changing where backups are stored
Emacs, just like Vim, makes regular backups of file that are undergoing active
editing. This feature is very nice as it might save you at some point when you
make a mistake. However, the Emacs backup files quickly clutter your inventory
and make you constantly include them in a =.gitignore=, as you do not want these
to fill your repositories. Much better behavior is to actually store them in a
separate directory from which you can easily retrieve them if you have to.
If you wish, you can also tell Emacs how many versions you wish to keep, but I
just keep with the defaults (2) for now.
#+begin_src emacs-lisp :tangle yes
  (setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
        backup-by-copying t    ; Don't delink hardlinks
        version-control t      ; Use version numbers on backups
        delete-old-versions t  ; Automatically delete excess backups
        ;; kept-new-versions 5    ; how many of the newest versions to keep
        ;; kept-old-versions 5    ; and how many of the old
        )
#+end_src

** Switching between windows
When programming I often have more than one window open. When you split a window
vertically using =C-x 3= the default behavior is to keep the focus (the
cursor) in the previous window. This is annoying. Luckily, there has been a
[[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org][programmer]] that was equally annoyed (but much more versed in emacs-lisp) and
wrote some nice functions to deal with this. Note that I only include the
vertical split as I basically never find myself splitting horizontally.
#+begin_src emacs-lisp :tangle yes
  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+end_src

** Showing emoji
As is know, emoji are critical for developers and scientists. But really, they
often explain a concept in a very concise manner and are incredibly useful when
used sparingly. The font that I have chosen personally ([[https://fonts.google.com/specimen/Roboto+Mono][Roboto Mono]]) does not
contain emoji support (as far as I know). So, we need to set the emoji font as
described [[https://github.com/emacs-lsp/lsp-mode/issues/2291#issuecomment-813097394][here]].
#+begin_src emacs-lisp :tangle yes
  ;; Emoji: üòÑ, ü§¶, üè¥
  (set-fontset-font t 'symbol "Apple Color Emoji")
  (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
  (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
  (set-fontset-font t 'symbol "Symbola" nil 'append)
#+end_src

* Adding a terminal to Emacs
When programming I often find myself reaching for a terminal window to, for
example, quickly install a package using =apt=, browsing through my current
working directory (although I should probably do this using Emacs...), and many
other things. As we do not want to leave the safety of our carefully crafted
Emacs environment, we need a terminal window. I currently use
[[https://github.com/akermu/emacs-libvterm][vterm]], as I found
it provides the most complete terminal experience. Do note that it is still in
Œ±-stage, so please be aware of (fundamental) changes down the line!
#+begin_src emacs-lisp :tangle yes
  (use-package vterm
    :ensure t
    :init
    (setq vterm-timer-delay 0.01))
#+end_src
Afterwards you might want to [[https://github.com/akermu/emacs-libvterm#shell-side-configuration][configure the shell]] as well.
Additionally we choose a global key combination to open vterm, in this case
=C-`=.
#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-`") `vterm)
#+end_src

* Visual configurations
** Color theme
Of course, no editor is your own when it does not look like your own. The
specific theme is my personal preference, so please feel free to change it to a
theme that better suits your needs.
[[https://github.com/bbatsov/zenb
urn-emacs][Zenburn]] for Emacs is a direct port of the Zenburn theme originally created for
vim. I (and others) think it is one of the best low contrast color themes out
there that is super easy on the eyes and has pastel colors!
#+begin_src emacs-lisp :tangle yes
  (use-package zenburn-theme
    :ensure t
    :config (load-theme 'zenburn t))
#+end_src

However, as I *really* like pastel colors, the [[https://github.com/mvarela/Sunburn-Theme][Sunburn]] color theme scratches the
right itch as it includes more shades of gray and purple -- but still very
pastel! Sadly, it is not available on ELPA/MELPA, so we need to install and load
in manually.
NOTE: Although this theme has some *really* nice colors, it feels less polished
and easy on the eyes that Zenburn. It would be very nice to, at some point in
the future, combine the two to create the 'ultimate' /burn/-theme.
#+begin_src emacs-lisp :tangle no
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/sunburn-theme-20231101.1")
  (load-theme 'sunburn)
#+end_src

Catppuccin also has a nice range of pastel colors in four different 'flavors'.
#+begin_src emacs-lisp :tangle no
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes/catppuccin-theme-20231101.1")
  (load-theme 'catppuccin t)
  (setq catppuccin-flavor 'frappe)
  (catppuccin-reload)
#+end_src
NOTE: Although this theme has great colors, there are some things that are not
wel configured. Similar to the Sunburn theme above, it needs some more work to
actually fit my preferred style, although it has some potential!

** Change the startup screen
#+begin_src emacs-lisp :tangle yes
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook))
  ;; Set the title
  (setq dashboard-banner-logo-title "Welcome Johannes")
  ;; Set the banner
  (setq dashboard-startup-banner 'logo)
  ;; Center content
  (setq dashboard-center-content t)
  ;; Customize widgets
  (setq dashboard-items '((recents . 5)
                          (bookmarks . 5)))
  ;; Disable random footnote
  (setq dashboard-set-footer nil)
#+end_src

** Change how [[https://github.com/akermu/emacs-libvterm][vterm]] is displayed when opened
The vterm normally opens (I think?) in an already opened buffer. This is often
unwanted as you want to use the terminal on the side while keeping your current
active buffer open. My personal preference is to open the terminal on the bottom
-- mainly because I am used to that from my VSCode days.
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'display-buffer-alist
               '("\*vterm\*"
                 (display-buffer-in-side-window)
                 (window-height . 0.275)         ;; Specify fraction of window height
                 (side . bottom)
                 (slot . 0)))
#+end_src

** Change the modeline
The modeline in Emacs is the single-line below each buffer in a window. It can
display important information on the opened file, such as the Git branch, the
filename, and [[https://www.emacswiki.org/emacs/ModeLine][much more]]. While I have played around with some configurations, I
find the default modeline quite respectable, and tweaking the modeline was quite
difficult.
So, current modifications is just to include the column number in the modeline.
#+begin_src emacs-lisp :tangle yes
  (setq column-number-mode t)
#+end_src
In some cases, the modeline becomes too full (looking at you =lsp-mode=). We can
hide (i.e. [[https://github.com/myrjola/diminish.el][diminish]]) their appearance while they still work for us in the
background. This is useful for many packages that are basically always loaded,
like snippets, =which-key=, etc.
#+begin_src emacs-lisp :tangle yes
  (use-package diminish
    :ensure t)
  (diminish 'eldoc-mode)
  (diminish 'visual-line-mode)
#+end_src

** Change the frame title
The frame title is displayed on top of the Emacs frame and can be configured as
well. I do not look at the top of the frame often, so we will just let it
display the filename and the Emacs version for now
#+begin_src emacs-lisp :tangle yes
(setq frame-title-format '("" "[%b] - Emacs " emacs-version))
#+end_src

* Enriching Emacs functionality
** Navigating buffers
Navigating the current buffer can sometimes be a hassle as you have to press the
arrow keys or, in extreme cases, use the mouse (/shudder/). Sometimes you need
to be at very specific points in a document, and luckily for me there exists a
beautiful package that handles this: =avy=. While explaining it sounds complex,
it boils down to =M-x avy-goto-char= (rebound to =M-s=) and pressing a specific
letter or key. On each instance of the key a letter will appear and pressing
that letter will bring you immediately to that destination. Just try it!
#+begin_src emacs-lisp :tangle yes
(use-package avy
  :ensure t
  :bind ("M-s" . avy-goto-char))
#+end_src

** Interactive completion of Emacs functions
[[https://github.com/minad/vertico][Vertico]] provides us with a minimalistic vertical completion UI that is based on
the default completion system. Simple, yet powerful.
#+begin_src emacs-lisp :tangle yes
  (use-package vertico
    :ensure t
    :init (vertico-mode))
#+end_src

And let Vertico persist the history over Emacs restarts, so we can, if we want,
quickly re-open files that we opened in a previous session.
#+begin_src emacs-lisp :tangle yes
  (use-package savehist
    :init (savehist-mode))
#+end_src

As with Vertico the order of the regexp matters, it is often convenient to
invoke [[https://github.com/oantolin/orderless][Orderless]], which makes the completion style match multiple regexps in any
order. For example, I can "M-x ins pac" and "M-x package-install" will likely be
the top candidate.
#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
** Show active bindings using =which-key=
[[https://github.com/justbur/emacs-which-key/][=which-key=]] is a minor mode for Emacs that displays the key bindings following
your currently entered incomplete command in a popup. This is super useful when
using new packages as you often are not aware of all the shortcuts. With
=which-key= you only have to remember the prefix, not the entire command. For
example, you can press =C-x= and after (the default of) 1 second the minibuffer
will expand with the keybindings that follow =C-x=.
#+begin_src emacs-lisp :tangle yes
  (use-package which-key
    :ensure t
    :config
    (which-key-mode)
    :diminish which-key-mode)
#+end_src
** Annotations in the minibuffer
In many cases, especially when using relatively obscure Emacs functionality, it
becomes unclear what a specific command does. [[https://github.com/minad/marginalia][Marginalia]] adds annotation in the
minibuffer that explains the function of the command. This makes it very useful
when using =M-x= functions, especially when combined with the above initialize
completion frameworks.
#+begin_src emacs-lisp :tangle yes
  (use-package marginalia
    :ensure t
    :init
    (marginalia-mode))
#+end_src

** Mini-buffer actions with Embark
When having the cursor at a specific point when using Emacs, you often need to
think about what to do with a selected region before you can do this. However,
it can be easier. [[https://github.com/oantolin/embark][Embark]] enables you to suggest what to do with a specific
selection, before you even think what to do with it. Effectively, it acts like a
'right-click' on a piece of text in any other software. Is the text a link?
Embark will suggest you to open it in a browser. Is it a list? Embark might
suggest you to order the list based on some constraints. The list goes on and
on. Embark comes with hundreds of actions preconfigures and, of course, they can
be tailored to your needs if needed.
#+begin_src emacs-lisp :tangle yes
  (use-package embark
    :ensure t
    :bind
    ("C-." . embark-act)
    :init
    :config

    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))
#+end_src

* Emacs YASnippets
No modern editor is complete without inserting large, pre-formatted textblocks
into your files with the press of a button. What separates a fast programmer (or
writer) from a slow one is basically the use of 'snippets'. For example, all
elisp source code blocks in this Org file are inserted with the =elisp_<TAB>=
button combination. I personally use [[https://github.com/joaotavora/yasnippet][YASnippet]] in combination with a popular
repository that contains snippets for a lot of modes, [[https://github.com/AndreaCrotti/yasnippet-snippets][YASnippet-snippets]].
Snippets themselves should also be included in this repository, see the
file:snippets/ directory.
#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure t
    :diminish yas-global-mode
    :config (yas-global-mode))
  (use-package yasnippet-snippets
    :after yasnippet
    :ensure t
    :config (yasnippet-snippets-initialize))
#+end_src

* Mode-specific configurations
** Text completion using Company
[[https://company-mode.github.io/][Company]] (COMPletion ANYwhere) is a text completion framework for Emacs. It pops
up a small UI that shows you candidates for the symbols you have currently
typed, making development much faster and avoid spelling mistakes, e.g. in
function names.
#+begin_src emacs-lisp :tangle yes
  (use-package company
    :ensure t
    :diminish global-company-mode
    :hook (after-init-hook . global-company-mode))
#+end_src
** Language server
When coding one wants a so-called 'IDE-like experience', in that your text
editor recognizes previously defined function for autocompletion, displays
documentation of functions, checks syntax errors, etc. Emacs provides these
features using =lsp-mode=; a mode that supports *all* language features defined
in the Language Server Protocol (LSP). As always, Emacs' =lsp-mode= is highly
flexible and easy to configure and works well with popular Emacs packages like
=company=, =flycheck= and =projectile=.
#+begin_src emacs-lisp :tangle yes
  (use-package lsp-mode
    :ensure t  
    :commands (lsp lsp-deferred)
    :init
    ;; Usually the =lsp-keymap-prefix= is bound to "C-c l", but this is already
    ;; bound to the (very useful!) =org-store-link=, which we do not want to
    ;; override. "C-c o" ('o' for option) was empty, so use it here.
    (setq lsp-keymap-prefix "C-c o")
    :config
    (define-key lsp-mode-map (kbd lsp-keymap-prefix) lsp-command-map)
    :hook (;; add modes
           (julia-mode . lsp-deferred)
           (julia-ts-mode . lsp-deferred)
           ;; =lsp-enable-which-key-integration= gives us descriptions of what the keys
           ;; do, which helps us figure out what they do when using =lsp-mode=.
           (lsp-mode . lsp-enable-which-key-integration)))
#+end_src

*** Languages
  For =lsp-mode= to function we need to install the language server for the
  languages that we are interested in. Currently, i do most of my development in
  Julia and Python, so those will be the language servers that will be installed
  below.
  !! IMPORTANT: it is important to add a hook to =lsp-mode= for the specifical
  =<language>-mode= when defining and configuring the mode (see [[*Julia configuration][here]] for an example).
  *Languages currently supported*
  1. [[*julia][Julia]]
  2. ...
**** Julia
#+begin_src emacs-lisp :tangle yes
  (use-package lsp-julia
    :ensure t
    :config
    (setq lsp-julia-default-environment "~/.julia/environments/v1.8"))
#+end_src

** Org mode
Org mode comes with a lot of possible configurations, so these are just a very
small selection of what is actually possible.
*** Default behaviors
The default bullets of Org are quite ugly (just bullets basically), so we make
them look a little bit better. The same goes for the collapsed headers, called
the 'ellipsis'.
#+begin_src emacs-lisp :tangle yes
  (use-package org-bullets
  	:ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  (setq org-ellipsis "‚§µ")
#+end_src

Support shift selecting blocks of text as well, as described [[https://orgmode.org/manual/Conflicts.html][here]].
#+begin_src emacs-lisp :tangle yes
  (setq org-support-shift-select t)
#+end_src

Next up is changing the look of source code blocks (like the elisp blocks in
this Org file).
#+begin_src emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
#+end_src

Change the default behavior of Org timestamps to actually note the time
and date when logging TODO's.
#+begin_src emacs-lisp :tangle yes
  (setq org-log-done t)
#+end_src

It is inconvenient to have to =M-x auto-fill-mode= every time you open an Org
file. However, line wrapping (not only visually line wrapping, as when using
=visual-line-mode-) is basically a must. Therefore, we add a hook that enables
this every time we open an Org file.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'org-mode-hook #'auto-fill-mode)
  (add-hook 'org-mode-hook #'visual-line-mode)
#+end_src

Org links are by default openen in another window (i.e. it splits the current
window in 2), which I think is undesired in many cases other than just quickly
checking the file out. To change this default behavior, we need to change the
value of =org-link-frame-setup=
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'org-link-frame-setup '(file . find-file))
#+end_src

*** Global org keys
I currently do not use a lot or Org functionality, so I should update this
section on global keys and what they do when I actually have some experience
with them. 
#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-c l") #'org-store-link)
  (global-set-key (kbd "C-c a") #'org-agenda)
  (global-set-key (kbd "C-c c") #'org-capture)
#+end_src

*** Org-mode configuration
**** Citation with citar
As we would like to cite items from some =.bib= file (perhaps one that is
handled by external library applications such as Zotero), we use [[https://github.com/emacs-citar/citar][Citar]].
This takes care of the dirty work and simply allows us to insert
citations as if we were writing LaTeX! We can also specify a (shared) global
bibliography and add any other (local) bibliographies within the Org files
themselves if we want.
#+begin_src emacs-lisp :tangle yes
  (use-package citar
    :custom
    (org-cite-global-bibliography '("~/work/papers/better-bibtex/postdoc.bib"))
    (org-cite-insert-processor 'citar)
    (org-cite-follow-processor 'citar)
    (org-cite-activate-processor 'citar)
    (citar-bibliography org-cite-global-bibliography)
    ;; optional: (or )rg-cite-insert is also bound to C-c C-x C-@
    :bind
    (:map org-mode-map :package org ("C-c i c" . #'org-cite-insert)))
#+end_src

To ensure that Citar works well together with [[Mini-buffer actions][Embark]] we load the =citar-embark=
package that adds contextual access in the minibuffer.
#+begin_src emacs-lisp :tangle yes
  (use-package citar-embark
    :after citar embar
    :no-require t
    :config (citar-embark-mode))
#+end_src

**** Capture templates
Within the Org-mode infrastructure, *Capture* allows you to quickly store a note
with little to no interruption of the current work flow. We  can use templates
for different types of capture items, such as TODOs. Here, we copy the example
from the Org-mode documentation that describes a template to create general TODO
entries and put these under the heading 'Tasks' in our main task =.org= file.
#+begin_src emacs-lisp :tangle yes
  (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/work/tasks/org/todo.org" "Tasks")
         "* TODO %?\n  %i\n  %a")))
#+end_src

*** Org-roam configuration
#+begin_src emacs-lisp :tangle yes
  (use-package org-roam
    :custom
    (org-roam-directory "~/work/notes/org-roam/")
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-C n i" . org-roam-node-insert))
    :config (org-roam-setup))
#+end_src

**** TODO Use Org-roam more often, make a sensible configuration and write some supporting text on the configuration. 

** LaTeX configuration
LaTeX is super nice, but compiling LaTeX is not so nice. Therefore we want to
automate as much as we can so we can actually focus on writing only. This of
course includes heavy use of [[YASnippets]] (e.g. for =\align= environments), but
also includes quick (re-)compiling of =.tex= files, building a bibliography,
etc. Working with LaTeX and (external) PDF viewers could be a chapter on its
own, but most of the keybindings provides below speak for themselves. The
configuration is built on top of [[https://www.gnu.org/software/auctex/][AUCTeX]], which is an extensible package for
writing an formatting TeX files in Emacs. 
#+begin_src emacs-lisp :tangle yes
  (use-package tex
    :ensure auctex
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq-default TeX-master nil))
#+end_src
While there exist some pdf tools that can display the rendered PDF in an Emacs
window and provide Emacs functionality (such as [[https://www.emacswiki.org/emacs/IncrementalSearch][isearch]]), the viewers convert
the PDF to a PNG and thereby losing resolution. While you can fiddle with the
dpi settings, I prefer to use a better PDF-viewer instead
There are, of course, multiple options. One of the first I used happily was
[[https://wiki.gnome.org/Apps/Evince][Evince]]. For Evince, the following configuration is given.
#+begin_src emacs-lisp :tangle no
  (setq TeX-view-program-list '(("Evince" "evince --page-index=%(outpage) %o")))
  (setq TeX-view-program-selection '((output-pdf "Evince")))
#+end_src
However, I found that with Evince it is difficult to change the background color
without hacking into the source code. The white background, however, is quite a
strain on the eyes during development. And it is not pastel enough of
course. Luckily for us, there exists a PDF viewer, called [[https://pwmt.org/projects/zathura/][Zathura]], which is
highly custimizable and minimalistic. Moreover, the [[https://github.com/catppuccin/catppuccin][catppuccin team]] has made
some [[https://github.com/catppuccin/zathura][nice themes]] available for Zathura, so we use one of the themes and use
Zathura as our main PDF-viewer.
#+begin_src emacs-lisp :tangle yes
  (setq TeX-view-program-selection '((output-pdf "Zathura")))
#+end_src

Additionaly, when we recompile a TeX file we want the PDF viewer to see the
updated PDF, so we 'correlate' the TeX and the PDF.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
#+end_src

And update the PDF buffers after a successful LaTeX run.
#+begin_src emacs-lisp :tangle yes
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
#+end_src

Finally, we change the keybinding of the 'save-render-show' procedure when in
LaTeX-mode.
** Markdown configuration
While Org mode is nice and all, I find myself reverting to Markdown in many
cases. Most often for a =README.md= that is included in a Git repository. But it
is nice to know that Org does support conversion to Markdown!
Currently, as Markdown is a super simple (and therefore useful!) text format,
the only thing I find myself using non-default behaviors is my preference of
displaying emojis -- so enable that here.
#+begin_src emacs-lisp :tangle yes
  (use-package emojify
    :hook (markdown-mode . emojify-mode))
#+end_src

** Python configuration
Currently I write most of my code in Python, so we need some code completion and
things to make writing Python code less of a chore. First, let us fix the tab width
#+begin_src emacs-lisp :tangle yes
(add-hook 'python-mode-hook
      (lambda ()
        (setq indent-tabs-mode nil)
        (setq tab-width 4)
        (setq python-indent-offset 4)))
#+end_src

*** Autocompletion
Currently I use [[http://tkf.github.io/emacs-jedi/released/#][Jedi.el]] for Python auto-completion. Besides completion is also
enables a small pop-up screen that shows information about a function or class,
code location, and more.
#+begin_src emacs-lisp :tangle yes
  (use-package jedi
    :hook (python-mode . jedi:setup)
    (setq jedi:complete-on-dot t))
#+end_src

*** IPython Notebook
As much of the current development of Python code occurs in IPython Notebooks,
such as a Jupyter Notebook, we would like to have this functionality in Emacs as
well.
Please do note that Emacs is **not** an Electron app (which is good!), so that
some IPython functionality is not supported by default. More specifically, all
things that are related to Javascript are not easily supported. This should not
discourage you from using Emacs however, as you can use the Jedi.el Python
completion backend right here in your IPython Notebook! And I can assure you
that that one is much better, and much more configurable, then Jupyter
Notebook's default code completer.

Currently, I use [[https://github.com/millejoh/emacs-ipython-notebook][Emacs Ipython Notebook (EIN)]] as it proved to be the most
successful one. The basic workflow, in order to support =conda= virtual
environments as the Python kernel, is to start a Jupyter Notebook from the
terminal and hook Emacs to that running kernel on your localhost using
=ein:login=. In this way we do not have to fiddle much with Python kernels,
virtual environments, and more. In the future we might want to make EIN know
about our virtual environments and spin up a IPython kernel itself.
#+begin_src emacs-lisp :tangle yes
  (use-package ein
  	:ensure t
    :config
    (setq ein:completion-backend 'ein:use-ac-jedi-backend))
#+end_src

** Julia configuration
I want to start writing most of my code in [[https://julialang.org/][Julia]] as it is very appealing for
scientific computing. While in general the support for Julia is not as
widespread as Python's, there is significant movement leading to a bunch of
tools (for Emacs). The most important one is [[https://github.com/JuliaEditorSupport/julia-emacs][Julia-mode]].
#+begin_src emacs-lisp :tangle no
  (use-package julia-mode
    :ensure t
    ;; Specify the hook that connects =lsp-mode=
    :hook (julia-mode-hook . lsp-mode))
#+end_src
Note: =julia-mode= does not highlight syntax very well.
#+begin_src emacs-lisp :tangle yes
  (use-package julia-ts-mode
    :ensure nil
    :load-path "~/.emacs.d/local-packages/julia-ts-mode/"
    :hook (julia-ts-mode-hook . lsp-mode))
#+end_src

The Julia REPL is quite a useful tool when writing and debugging, so we want to
add support for a good REPL in Emacs. Sadly, [[https://github.com/tpapp/julia-repl][julia-repl]] is not not available
through MELPA, so we cannot use =use-package= to automate the installation but
have to resort to manually downloading the relevant =elisp= files.
#+begin_src emacs-lisp :tangle yes
  (use-package julia-repl
    :ensure t
    :hook (julia-ts-mode . julia-repl-mode)

    :config
    ;; Set the terminal backend
    (julia-repl-set-terminal-backend 'vterm)

    ;; Keybindings for quickly sending code to the REPL
    (define-key julia-repl-mode-map (kbd "<M-RET>") 'my/julia-repl-send-cell))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (defun my/julia-repl-send-cell() 
    ;; "Send the current julia cell (delimited by ###) to the julia shell"
    (interactive)
    (save-excursion
      (setq cell-begin (if (re-search-backward "^###" nil t) (point) (point-min))))
    (save-excursion
      (setq cell-end (if (re-search-forward "^###" nil t) (point) (point-max))))
    (set-mark cell-begin)
    (goto-char cell-end)
    (julia-repl-send-region-or-line)
    (next-line))
#+end_src


